/**
 * SketchConverter
 * Copyright(c) 2020 KLab, Inc. All Rights Reserved.
 * Proprietary and Confidential - This source code is not for redistribution
 *
 * Subject to the prior written consent of KLab, Inc(Licensor) and its terms and
 * conditions, Licensor grants to you, and you hereby accept nontransferable,
 * nonexclusive limited right to access, obtain, use, copy and/or download
 * a copy of this product only for requirement purposes. You may not rent,
 * lease, loan, time share, sublicense, transfer, make generally available,
 * license, disclose, disseminate, distribute or otherwise make accessible or
 * available this product to any third party without the prior written approval
 * of Licensor. Unauthorized copying of this product, including modifications 
 * of this product or programs in which this product has been merged or included
 * with other software products is expressly forbidden.
 */

// <auto-generated />
//
// To parse this JSON data, add NuGet 'SketchConverter.Newtonsoft.Json' then do:
//
//    using SketchConverter.FileFormat;
//
//    var sketchFileFormatDesigner = SketchFileFormatDesigner.FromJson(jsonString);

namespace SketchConverter.FileFormat
{
    using System;
    using System.Collections.Generic;

    using System.Globalization;
    using SketchConverter.Newtonsoft.Json;
    using SketchConverter.Newtonsoft.Json.Converters;

    /// <summary>
    /// This schema describes a representation of an expanded Sketch file, that is, a Sketch file
    /// that has been unzipped, all of its entries parsed to JSON and merged into a single
    /// object. A concrete example of an expanded sketch file is the return value of the
    /// `fromFile` function
    /// </summary>
    public partial class SketchFileFormatDesigner
    {
        [JsonProperty("document")]
        public DocumentClass Document { get; set; }

        [JsonProperty("meta")]
        public Meta Meta { get; set; }

        [JsonProperty("page")]
        public PageClass Page { get; set; }

        [JsonProperty("user")]
        public Dictionary<string, UserValue> User { get; set; }

        [JsonProperty("workspace", NullValueHandling = NullValueHandling.Ignore)]
        public Workspace Workspace { get; set; }
    }

    public partial class DocumentClass
    {
        [JsonProperty("_class")]
        public dynamic Class { get; set; }

        [JsonProperty("assets")]
        public AssetCollection Assets { get; set; }

        [JsonProperty("colorSpace")]
        public long ColorSpace { get; set; }

        [JsonProperty("currentPageIndex")]
        public long CurrentPageIndex { get; set; }

        [JsonProperty("do_objectID")]
        public string DoObjectId { get; set; }

        [JsonProperty("documentState", NullValueHandling = NullValueHandling.Ignore)]
        public Dictionary<string, dynamic> DocumentState { get; set; }

        [JsonProperty("fontReferences", NullValueHandling = NullValueHandling.Ignore)]
        public FontReference[] FontReferences { get; set; }

        [JsonProperty("foreignLayerStyles")]
        public ForeignLayerStyle[] ForeignLayerStyles { get; set; }

        [JsonProperty("foreignSwatches", NullValueHandling = NullValueHandling.Ignore)]
        public ForeignSwatch[] ForeignSwatches { get; set; }

        [JsonProperty("foreignSymbols")]
        public ForeignSymbol[] ForeignSymbols { get; set; }

        [JsonProperty("foreignTextStyles")]
        public ForeignTextStyle[] ForeignTextStyles { get; set; }

        [JsonProperty("layerStyles")]
        public SharedStyleContainer LayerStyles { get; set; }

        [JsonProperty("layerSymbols", NullValueHandling = NullValueHandling.Ignore)]
        public SymbolContainer LayerSymbols { get; set; }

        [JsonProperty("layerTextStyles")]
        public SharedTextStyleContainer LayerTextStyles { get; set; }

        [JsonProperty("pages")]
        public FileReference[] Pages { get; set; }

        [JsonProperty("sharedSwatches", NullValueHandling = NullValueHandling.Ignore)]
        public SwatchContainer SharedSwatches { get; set; }
    }

    /// <summary>
    /// Collection of global document objects
    /// </summary>
    public partial class AssetCollection
    {
        [JsonProperty("_class")]
        public dynamic Class { get; set; }

        [JsonProperty("colorAssets")]
        public ColorAsset[] ColorAssets { get; set; }

        [JsonProperty("colors")]
        public Color[] Colors { get; set; }

        [JsonProperty("do_objectID")]
        public string DoObjectId { get; set; }

        [JsonProperty("exportPresets")]
        public dynamic[] ExportPresets { get; set; }

        [JsonProperty("gradientAssets")]
        public GradientAsset[] GradientAssets { get; set; }

        [JsonProperty("gradients")]
        public Gradient[] Gradients { get; set; }

        [JsonProperty("imageCollection", NullValueHandling = NullValueHandling.Ignore)]
        public ImageCollection ImageCollection { get; set; }

        [JsonProperty("images")]
        public ImageElement[] Images { get; set; }
    }

    /// <summary>
    /// Defines a reusable color asset
    /// </summary>
    public partial class ColorAsset
    {
        [JsonProperty("_class")]
        public dynamic Class { get; set; }

        [JsonProperty("color")]
        public Color Color { get; set; }

        [JsonProperty("do_objectID")]
        public string DoObjectId { get; set; }

        [JsonProperty("name")]
        public string Name { get; set; }
    }

    /// <summary>
    /// Defines a RGBA color value
    /// </summary>
    public partial class Color
    {
        [JsonProperty("_class")]
        public dynamic Class { get; set; }

        [JsonProperty("alpha")]
        [JsonConverter(typeof(PurpleMinMaxValueCheckConverter))]
        public double Alpha { get; set; }

        [JsonProperty("blue")]
        [JsonConverter(typeof(PurpleMinMaxValueCheckConverter))]
        public double Blue { get; set; }

        [JsonProperty("green")]
        [JsonConverter(typeof(PurpleMinMaxValueCheckConverter))]
        public double Green { get; set; }

        [JsonProperty("red")]
        [JsonConverter(typeof(PurpleMinMaxValueCheckConverter))]
        public double Red { get; set; }

        [JsonProperty("swatchID", NullValueHandling = NullValueHandling.Ignore)]
        public string SwatchId { get; set; }
    }

    /// <summary>
    /// Defines a reusable gradient asset
    /// </summary>
    public partial class GradientAsset
    {
        [JsonProperty("_class")]
        public dynamic Class { get; set; }

        [JsonProperty("do_objectID")]
        public string DoObjectId { get; set; }

        [JsonProperty("gradient")]
        public Gradient Gradient { get; set; }

        [JsonProperty("name")]
        public string Name { get; set; }
    }

    /// <summary>
    /// Defines a gradient
    /// </summary>
    public partial class Gradient
    {
        [JsonProperty("_class")]
        public dynamic Class { get; set; }

        [JsonProperty("elipseLength")]
        public double ElipseLength { get; set; }

        [JsonProperty("from")]
        public string From { get; set; }

        [JsonProperty("gradientType")]
        public long GradientType { get; set; }

        [JsonProperty("stops")]
        public GradientStop[] Stops { get; set; }

        [JsonProperty("to")]
        public string To { get; set; }
    }

    /// <summary>
    /// Defines a position on a gradient that marks the end of a transition to a new color
    /// </summary>
    public partial class GradientStop
    {
        [JsonProperty("_class")]
        public dynamic Class { get; set; }

        [JsonProperty("color")]
        public Color Color { get; set; }

        [JsonProperty("position")]
        [JsonConverter(typeof(PurpleMinMaxValueCheckConverter))]
        public double Position { get; set; }
    }

    /// <summary>
    /// Legacy object only retained for migrating older documents.
    /// </summary>
    public partial class ImageCollection
    {
        [JsonProperty("_class")]
        public dynamic Class { get; set; }

        [JsonProperty("images")]
        public Images Images { get; set; }
    }

    public partial class Images
    {
    }

    /// <summary>
    /// Defines a reference to a file within the document bundle
    ///
    /// Defines inline base64 data
    /// </summary>
    public partial class ImageElement
    {
        [JsonProperty("_class")]
        public dynamic Class { get; set; }

        [JsonProperty("_ref")]
        public string Ref { get; set; }

        [JsonProperty("_ref_class")]
        public ImageRefClass RefClass { get; set; }

        [JsonProperty("data", NullValueHandling = NullValueHandling.Ignore)]
        public Data Data { get; set; }

        [JsonProperty("sha1", NullValueHandling = NullValueHandling.Ignore)]
        public Sha1 Sha1 { get; set; }
    }

    public partial class Data
    {
        [JsonProperty("_data")]
        public string DataData { get; set; }
    }

    public partial class Sha1
    {
        [JsonProperty("_data")]
        public string Data { get; set; }
    }

    /// <summary>
    /// Defines a reference to font data embedded in the document
    /// </summary>
    public partial class FontReference
    {
        [JsonProperty("_class")]
        public dynamic Class { get; set; }

        [JsonProperty("fontData")]
        public DataReference FontData { get; set; }

        [JsonProperty("fontFamilyName")]
        public string FontFamilyName { get; set; }

        [JsonProperty("fontFileName")]
        public string FontFileName { get; set; }

        [JsonProperty("options")]
        public long Options { get; set; }

        [JsonProperty("postscriptNames")]
        public string[] PostscriptNames { get; set; }
    }

    /// <summary>
    /// Defines inline base64 data
    /// </summary>
    public partial class DataReference
    {
        [JsonProperty("_class")]
        public dynamic Class { get; set; }

        [JsonProperty("_ref")]
        public string Ref { get; set; }

        [JsonProperty("_ref_class")]
        public FontDataRefClass RefClass { get; set; }

        [JsonProperty("data")]
        public Data Data { get; set; }

        [JsonProperty("sha1")]
        public Sha1 Sha1 { get; set; }
    }

    /// <summary>
    /// Defines a layer style that has been imported from a library
    /// </summary>
    public partial class ForeignLayerStyle
    {
        [JsonProperty("_class")]
        public dynamic Class { get; set; }

        [JsonProperty("do_objectID")]
        public string DoObjectId { get; set; }

        [JsonProperty("libraryID")]
        public string LibraryId { get; set; }

        [JsonProperty("localSharedStyle")]
        public SharedStyle LocalSharedStyle { get; set; }

        [JsonProperty("remoteStyleID")]
        public string RemoteStyleId { get; set; }

        [JsonProperty("sourceLibraryName")]
        public string SourceLibraryName { get; set; }

        [JsonProperty("symbolPrivate")]
        public bool SymbolPrivate { get; set; }
    }

    /// <summary>
    /// Defines a reusable style
    /// </summary>
    public partial class SharedStyle
    {
        [JsonProperty("_class")]
        public dynamic Class { get; set; }

        [JsonProperty("do_objectID")]
        public string DoObjectId { get; set; }

        [JsonProperty("name")]
        public string Name { get; set; }

        [JsonProperty("value")]
        public Style Value { get; set; }
    }

    /// <summary>
    /// Defines a layer style
    /// </summary>
    public partial class Style
    {
        [JsonProperty("_class")]
        public dynamic Class { get; set; }

        [JsonProperty("blur", NullValueHandling = NullValueHandling.Ignore)]
        public Blur Blur { get; set; }

        [JsonProperty("borderOptions")]
        public BorderOptions BorderOptions { get; set; }

        [JsonProperty("borders", NullValueHandling = NullValueHandling.Ignore)]
        public Border[] Borders { get; set; }

        [JsonProperty("colorControls")]
        public ColorControls ColorControls { get; set; }

        [JsonProperty("contextSettings", NullValueHandling = NullValueHandling.Ignore)]
        public GraphicsContextSettings ContextSettings { get; set; }

        [JsonProperty("do_objectID")]
        public string DoObjectId { get; set; }

        [JsonProperty("endMarkerType")]
        public long EndMarkerType { get; set; }

        [JsonProperty("fills", NullValueHandling = NullValueHandling.Ignore)]
        public Fill[] Fills { get; set; }

        [JsonProperty("innerShadows")]
        public InnerShadow[] InnerShadows { get; set; }

        [JsonProperty("miterLimit")]
        public long MiterLimit { get; set; }

        [JsonProperty("shadows", NullValueHandling = NullValueHandling.Ignore)]
        public Shadow[] Shadows { get; set; }

        [JsonProperty("startMarkerType")]
        public long StartMarkerType { get; set; }

        [JsonProperty("textStyle", NullValueHandling = NullValueHandling.Ignore)]
        public TextStyle TextStyle { get; set; }

        [JsonProperty("windingRule")]
        public long WindingRule { get; set; }
    }

    /// <summary>
    /// Defines a blur style
    /// </summary>
    public partial class Blur
    {
        [JsonProperty("_class")]
        public dynamic Class { get; set; }

        [JsonProperty("center")]
        public string Center { get; set; }

        [JsonProperty("isEnabled")]
        public bool IsEnabled { get; set; }

        [JsonProperty("motionAngle", NullValueHandling = NullValueHandling.Ignore)]
        public double? MotionAngle { get; set; }

        [JsonProperty("radius", NullValueHandling = NullValueHandling.Ignore)]
        public double? Radius { get; set; }

        [JsonProperty("saturation")]
        public double Saturation { get; set; }

        [JsonProperty("type")]
        public long Type { get; set; }
    }

    /// <summary>
    /// Defines border options
    /// </summary>
    public partial class BorderOptions
    {
        [JsonProperty("_class")]
        public dynamic Class { get; set; }

        [JsonProperty("dashPattern")]
        public double[] DashPattern { get; set; }

        [JsonProperty("isEnabled")]
        public bool IsEnabled { get; set; }

        [JsonProperty("lineCapStyle")]
        public long LineCapStyle { get; set; }

        [JsonProperty("lineJoinStyle")]
        public long LineJoinStyle { get; set; }
    }

    /// <summary>
    /// Defines a border style
    /// </summary>
    public partial class Border
    {
        [JsonProperty("_class")]
        public dynamic Class { get; set; }

        [JsonProperty("color")]
        public Color Color { get; set; }

        [JsonProperty("contextSettings")]
        public GraphicsContextSettings ContextSettings { get; set; }

        [JsonProperty("fillType")]
        public long FillType { get; set; }

        [JsonProperty("gradient")]
        public Gradient Gradient { get; set; }

        [JsonProperty("isEnabled")]
        public bool IsEnabled { get; set; }

        [JsonProperty("position")]
        public long Position { get; set; }

        [JsonProperty("thickness")]
        public double Thickness { get; set; }
    }

    /// <summary>
    /// Defines the opacity and blend mode of a style or shadow
    /// </summary>
    public partial class GraphicsContextSettings
    {
        [JsonProperty("_class")]
        public dynamic Class { get; set; }

        [JsonProperty("blendMode")]
        public long BlendMode { get; set; }

        [JsonProperty("opacity")]
        public double Opacity { get; set; }
    }

    /// <summary>
    /// Defines color adjust styles on images
    /// </summary>
    public partial class ColorControls
    {
        [JsonProperty("_class")]
        public dynamic Class { get; set; }

        [JsonProperty("brightness")]
        [JsonConverter(typeof(FluffyMinMaxValueCheckConverter))]
        public double Brightness { get; set; }

        [JsonProperty("contrast")]
        [JsonConverter(typeof(FluffyMinMaxValueCheckConverter))]
        public double Contrast { get; set; }

        [JsonProperty("hue")]
        [JsonConverter(typeof(FluffyMinMaxValueCheckConverter))]
        public double Hue { get; set; }

        [JsonProperty("isEnabled")]
        public bool IsEnabled { get; set; }

        [JsonProperty("saturation")]
        [JsonConverter(typeof(FluffyMinMaxValueCheckConverter))]
        public double Saturation { get; set; }
    }

    /// <summary>
    /// Defines a fill style
    /// </summary>
    public partial class Fill
    {
        [JsonProperty("_class")]
        public dynamic Class { get; set; }

        [JsonProperty("color")]
        public Color Color { get; set; }

        [JsonProperty("contextSettings")]
        public GraphicsContextSettings ContextSettings { get; set; }

        [JsonProperty("fillType")]
        public long FillType { get; set; }

        [JsonProperty("gradient")]
        public Gradient Gradient { get; set; }

        [JsonProperty("image", NullValueHandling = NullValueHandling.Ignore)]
        public ImageElement Image { get; set; }

        [JsonProperty("isEnabled")]
        public bool IsEnabled { get; set; }

        [JsonProperty("noiseIndex")]
        public double NoiseIndex { get; set; }

        [JsonProperty("noiseIntensity")]
        public double NoiseIntensity { get; set; }

        [JsonProperty("patternFillType")]
        public long PatternFillType { get; set; }

        [JsonProperty("patternTileScale")]
        public double PatternTileScale { get; set; }
    }

    /// <summary>
    /// Defines an inner shadow style
    /// </summary>
    public partial class InnerShadow
    {
        [JsonProperty("_class")]
        public dynamic Class { get; set; }

        [JsonProperty("blurRadius")]
        public double BlurRadius { get; set; }

        [JsonProperty("color")]
        public Color Color { get; set; }

        [JsonProperty("contextSettings")]
        public GraphicsContextSettings ContextSettings { get; set; }

        [JsonProperty("isEnabled")]
        public bool IsEnabled { get; set; }

        [JsonProperty("offsetX")]
        public double OffsetX { get; set; }

        [JsonProperty("offsetY")]
        public double OffsetY { get; set; }

        [JsonProperty("spread")]
        public double Spread { get; set; }
    }

    /// <summary>
    /// Defines a shadow style
    /// </summary>
    public partial class Shadow
    {
        [JsonProperty("_class")]
        public dynamic Class { get; set; }

        [JsonProperty("blurRadius")]
        public double BlurRadius { get; set; }

        [JsonProperty("color")]
        public Color Color { get; set; }

        [JsonProperty("contextSettings")]
        public GraphicsContextSettings ContextSettings { get; set; }

        [JsonProperty("isEnabled")]
        public bool IsEnabled { get; set; }

        [JsonProperty("offsetX")]
        public double OffsetX { get; set; }

        [JsonProperty("offsetY")]
        public double OffsetY { get; set; }

        [JsonProperty("spread")]
        public double Spread { get; set; }
    }

    /// <summary>
    /// Defines text style
    /// </summary>
    public partial class TextStyle
    {
        [JsonProperty("_class")]
        public dynamic Class { get; set; }

        [JsonProperty("encodedAttributes")]
        public EncodedAttributes EncodedAttributes { get; set; }

        [JsonProperty("verticalAlignment")]
        public long VerticalAlignment { get; set; }
    }

    public partial class EncodedAttributes
    {
        [JsonProperty("kerning", NullValueHandling = NullValueHandling.Ignore)]
        public double? Kerning { get; set; }

        [JsonProperty("MSAttributedStringColorAttribute", NullValueHandling = NullValueHandling.Ignore)]
        public Color MsAttributedStringColorAttribute { get; set; }

        [JsonProperty("MSAttributedStringFontAttribute")]
        public FontDescriptor MsAttributedStringFontAttribute { get; set; }

        [JsonProperty("MSAttributedStringTextTransformAttribute", NullValueHandling = NullValueHandling.Ignore)]
        public long? MsAttributedStringTextTransformAttribute { get; set; }

        [JsonProperty("paragraphStyle", NullValueHandling = NullValueHandling.Ignore)]
        public ParagraphStyle ParagraphStyle { get; set; }

        [JsonProperty("strikethroughStyle")]
        public dynamic StrikethroughStyle { get; set; }

        [JsonProperty("textStyleVerticalAlignmentKey", NullValueHandling = NullValueHandling.Ignore)]
        public long? TextStyleVerticalAlignmentKey { get; set; }

        [JsonProperty("underlineStyle", NullValueHandling = NullValueHandling.Ignore)]
        public long? UnderlineStyle { get; set; }
    }

    /// <summary>
    /// Defines a font selection
    /// </summary>
    public partial class FontDescriptor
    {
        [JsonProperty("_class")]
        public dynamic Class { get; set; }

        [JsonProperty("attributes")]
        public MsAttributedStringFontAttributeAttributes Attributes { get; set; }
    }

    public partial class MsAttributedStringFontAttributeAttributes
    {
        [JsonProperty("name")]
        public string Name { get; set; }

        [JsonProperty("size")]
        public double Size { get; set; }

        [JsonProperty("variation", NullValueHandling = NullValueHandling.Ignore)]
        public Dictionary<string, dynamic> Variation { get; set; }
    }

    /// <summary>
    /// Defines the paragraph style within a text style
    /// </summary>
    public partial class ParagraphStyle
    {
        [JsonProperty("_class")]
        public dynamic Class { get; set; }

        [JsonProperty("alignment", NullValueHandling = NullValueHandling.Ignore)]
        public long? Alignment { get; set; }

        [JsonProperty("allowsDefaultTighteningForTruncation", NullValueHandling = NullValueHandling.Ignore)]
        public double? AllowsDefaultTighteningForTruncation { get; set; }

        [JsonProperty("maximumLineHeight", NullValueHandling = NullValueHandling.Ignore)]
        public double? MaximumLineHeight { get; set; }

        [JsonProperty("minimumLineHeight", NullValueHandling = NullValueHandling.Ignore)]
        public double? MinimumLineHeight { get; set; }

        [JsonProperty("paragraphSpacing", NullValueHandling = NullValueHandling.Ignore)]
        public double? ParagraphSpacing { get; set; }
    }

    /// <summary>
    /// Defines a swatch that has been imported from a library
    /// </summary>
    public partial class ForeignSwatch
    {
        [JsonProperty("_class")]
        public dynamic Class { get; set; }

        [JsonProperty("do_objectID")]
        public string DoObjectId { get; set; }

        [JsonProperty("libraryID")]
        public string LibraryId { get; set; }

        [JsonProperty("localSwatch")]
        public Swatch LocalSwatch { get; set; }

        [JsonProperty("remoteSwatchID")]
        public string RemoteSwatchId { get; set; }

        [JsonProperty("sourceLibraryName")]
        public string SourceLibraryName { get; set; }

        [JsonProperty("symbolPrivate")]
        public bool SymbolPrivate { get; set; }
    }

    /// <summary>
    /// Defines a swatch color variable.
    /// </summary>
    public partial class Swatch
    {
        [JsonProperty("_class")]
        public dynamic Class { get; set; }

        [JsonProperty("do_objectID")]
        public string DoObjectId { get; set; }

        [JsonProperty("name")]
        public string Name { get; set; }

        [JsonProperty("value")]
        public Color Value { get; set; }
    }

    /// <summary>
    /// Defines a symbol that has been imported from a library
    /// </summary>
    public partial class ForeignSymbol
    {
        [JsonProperty("_class")]
        public dynamic Class { get; set; }

        [JsonProperty("do_objectID")]
        public string DoObjectId { get; set; }

        [JsonProperty("libraryID")]
        public string LibraryId { get; set; }

        [JsonProperty("missingLibraryFontAcknowledged", NullValueHandling = NullValueHandling.Ignore)]
        public bool? MissingLibraryFontAcknowledged { get; set; }

        [JsonProperty("originalMaster")]
        public SymbolSourceLayer OriginalMaster { get; set; }

        [JsonProperty("sourceLibraryName")]
        public string SourceLibraryName { get; set; }

        [JsonProperty("symbolMaster")]
        public SymbolSourceLayer SymbolMaster { get; set; }

        [JsonProperty("symbolPrivate")]
        public bool SymbolPrivate { get; set; }
    }

    /// <summary>
    /// A symbol source layer represents a reusable group of layers
    /// </summary>
    public partial class SymbolSourceLayer
    {
        [JsonProperty("_class")]
        public dynamic Class { get; set; }

        [JsonProperty("allowsOverrides")]
        public bool AllowsOverrides { get; set; }

        [JsonProperty("backgroundColor")]
        public Color BackgroundColor { get; set; }

        [JsonProperty("booleanOperation")]
        public long BooleanOperation { get; set; }

        [JsonProperty("clippingMaskMode", NullValueHandling = NullValueHandling.Ignore)]
        public long? ClippingMaskMode { get; set; }

        [JsonProperty("do_objectID")]
        public string DoObjectId { get; set; }

        [JsonProperty("exportOptions")]
        public ExportOptions ExportOptions { get; set; }

        [JsonProperty("flow", NullValueHandling = NullValueHandling.Ignore)]
        public FlowConnection Flow { get; set; }

        [JsonProperty("frame")]
        public Rect Frame { get; set; }

        [JsonProperty("grid", NullValueHandling = NullValueHandling.Ignore)]
        public SimpleGrid Grid { get; set; }

        [JsonProperty("groupLayout", NullValueHandling = NullValueHandling.Ignore)]
        public GroupLayout GroupLayout { get; set; }

        [JsonProperty("hasBackgroundColor")]
        public bool HasBackgroundColor { get; set; }

        [JsonProperty("hasClickThrough")]
        public bool HasClickThrough { get; set; }

        [JsonProperty("hasClippingMask", NullValueHandling = NullValueHandling.Ignore)]
        public bool? HasClippingMask { get; set; }

        [JsonProperty("horizontalRulerData")]
        public RulerData HorizontalRulerData { get; set; }

        [JsonProperty("includeBackgroundColorInExport")]
        public bool IncludeBackgroundColorInExport { get; set; }

        [JsonProperty("includeBackgroundColorInInstance")]
        public bool IncludeBackgroundColorInInstance { get; set; }

        /// <summary>
        /// Deprecated, no longer used by Sketch Cloud
        /// </summary>
        [JsonProperty("includeInCloudUpload")]
        public bool IncludeInCloudUpload { get; set; }

        [JsonProperty("isFixedToViewport")]
        public bool IsFixedToViewport { get; set; }

        [JsonProperty("isFlippedHorizontal")]
        public bool IsFlippedHorizontal { get; set; }

        [JsonProperty("isFlippedVertical")]
        public bool IsFlippedVertical { get; set; }

        [JsonProperty("isFlowHome")]
        public bool IsFlowHome { get; set; }

        [JsonProperty("isLocked")]
        public bool IsLocked { get; set; }

        [JsonProperty("isVisible")]
        public bool IsVisible { get; set; }

        [JsonProperty("layerListExpandedType")]
        public long LayerListExpandedType { get; set; }

        /// <summary>
        /// Symbol sources can contain any layer or layer group except root layers such as artboards
        /// and other symbol sources
        /// </summary>
        [JsonProperty("layers")]
        public OriginalMasterLayer[] Layers { get; set; }

        [JsonProperty("layout", NullValueHandling = NullValueHandling.Ignore)]
        public LayoutGrid Layout { get; set; }

        [JsonProperty("maintainScrollPosition", NullValueHandling = NullValueHandling.Ignore)]
        public bool? MaintainScrollPosition { get; set; }

        [JsonProperty("name")]
        public string Name { get; set; }

        [JsonProperty("nameIsFixed")]
        public bool NameIsFixed { get; set; }

        [JsonProperty("overrideProperties")]
        public OverrideProperty[] OverrideProperties { get; set; }

        [JsonProperty("presetDictionary", NullValueHandling = NullValueHandling.Ignore)]
        public OriginalMasterPresetDictionary PresetDictionary { get; set; }

        [JsonProperty("resizesContent")]
        public bool ResizesContent { get; set; }

        /// <summary>
        /// Bitfield representing the resizing constraint
        /// </summary>
        [JsonProperty("resizingConstraint")]
        public long ResizingConstraint { get; set; }

        [JsonProperty("resizingType")]
        public long ResizingType { get; set; }

        [JsonProperty("rotation")]
        public double Rotation { get; set; }

        [JsonProperty("sharedStyleID", NullValueHandling = NullValueHandling.Ignore)]
        public string SharedStyleId { get; set; }

        [JsonProperty("shouldBreakMaskChain")]
        public bool ShouldBreakMaskChain { get; set; }

        [JsonProperty("style", NullValueHandling = NullValueHandling.Ignore)]
        public Style Style { get; set; }

        [JsonProperty("symbolID")]
        public string SymbolId { get; set; }

        [JsonProperty("userInfo", NullValueHandling = NullValueHandling.Ignore)]
        public Dictionary<string, dynamic> UserInfo { get; set; }

        [JsonProperty("verticalRulerData")]
        public RulerData VerticalRulerData { get; set; }
    }

    /// <summary>
    /// Defines a layer's export options
    /// </summary>
    public partial class ExportOptions
    {
        [JsonProperty("_class")]
        public dynamic Class { get; set; }

        [JsonProperty("exportFormats")]
        public ExportFormat[] ExportFormats { get; set; }

        [JsonProperty("includedLayerIds")]
        public string[] IncludedLayerIds { get; set; }

        [JsonProperty("layerOptions")]
        public long LayerOptions { get; set; }

        [JsonProperty("shouldTrim")]
        public bool ShouldTrim { get; set; }
    }

    /// <summary>
    /// Defines an export format, as listed in a layer's export options
    /// </summary>
    public partial class ExportFormat
    {
        [JsonProperty("_class")]
        public dynamic Class { get; set; }

        [JsonProperty("absoluteSize")]
        public long AbsoluteSize { get; set; }

        [JsonProperty("fileFormat")]
        public ExportFileFormat FileFormat { get; set; }

        [JsonProperty("name")]
        public string Name { get; set; }

        [JsonProperty("namingScheme", NullValueHandling = NullValueHandling.Ignore)]
        public long? NamingScheme { get; set; }

        [JsonProperty("scale")]
        public double Scale { get; set; }

        [JsonProperty("visibleScaleType")]
        public long VisibleScaleType { get; set; }
    }

    /// <summary>
    /// Defines a connection between elements in a prototype
    /// </summary>
    public partial class FlowConnection
    {
        [JsonProperty("_class")]
        public dynamic Class { get; set; }

        [JsonProperty("animationType")]
        public long AnimationType { get; set; }

        [JsonProperty("destinationArtboardID")]
        public dynamic DestinationArtboardId { get; set; }

        [JsonProperty("maintainScrollPosition", NullValueHandling = NullValueHandling.Ignore)]
        public bool? MaintainScrollPosition { get; set; }
    }

    /// <summary>
    /// Defines an abstract rectangle
    /// </summary>
    public partial class Rect
    {
        [JsonProperty("_class")]
        public dynamic Class { get; set; }

        [JsonProperty("constrainProportions")]
        public bool ConstrainProportions { get; set; }

        [JsonProperty("height")]
        public double Height { get; set; }

        [JsonProperty("width")]
        public double Width { get; set; }

        [JsonProperty("x")]
        public double X { get; set; }

        [JsonProperty("y")]
        public double Y { get; set; }
    }

    /// <summary>
    /// Defines the grid settings for an artboard or page
    /// </summary>
    public partial class SimpleGrid
    {
        [JsonProperty("_class")]
        public dynamic Class { get; set; }

        [JsonProperty("gridSize")]
        public long GridSize { get; set; }

        [JsonProperty("isEnabled")]
        public bool IsEnabled { get; set; }

        [JsonProperty("thickGridTimes")]
        public long ThickGridTimes { get; set; }
    }

    /// <summary>
    /// Normal group layout
    ///
    /// Inferred group layout defines smart layout options
    /// </summary>
    public partial class GroupLayout
    {
        [JsonProperty("_class")]
        public dynamic Class { get; set; }

        [JsonProperty("axis", NullValueHandling = NullValueHandling.Ignore)]
        public long? Axis { get; set; }

        [JsonProperty("layoutAnchor", NullValueHandling = NullValueHandling.Ignore)]
        public long? LayoutAnchor { get; set; }

        [JsonProperty("maxSize", NullValueHandling = NullValueHandling.Ignore)]
        public double? MaxSize { get; set; }

        [JsonProperty("minSize", NullValueHandling = NullValueHandling.Ignore)]
        public double? MinSize { get; set; }
    }

    /// <summary>
    /// Defines persisted ruler positions on artboards, pages and symbols
    /// </summary>
    public partial class RulerData
    {
        [JsonProperty("_class")]
        public dynamic Class { get; set; }

        [JsonProperty("base")]
        public long Base { get; set; }

        [JsonProperty("guides")]
        public long[] Guides { get; set; }
    }

    /// <summary>
    /// Group layers are a document organisation aid
    ///
    /// Oval layers are the result of adding an oval shape to the canvas
    ///
    /// Polygon layers are the result of adding a polygon shape to the canvas
    ///
    /// Rectangle layers are the result of adding a rectangle shape to the canvas
    ///
    /// Shape path layers are the result of adding a vector layer
    ///
    /// Star layers are the result of adding a star shape to the canvas
    ///
    /// Triangle layers are the result of adding a triangle shape to the canvas
    ///
    /// Shape groups layers group together multiple shape layers
    ///
    /// A text layer represents a discrete block or line of text
    ///
    /// Symbol instance layers represent an instance of a symbol source
    ///
    /// Slice layers allow the content beneath their frame to be exported
    ///
    /// Hotspot layers define clickable hotspots for use with prototypes
    ///
    /// Bitmap layers house a single image
    /// </summary>
    public partial class OriginalMasterLayer
    {
        [JsonProperty("_class")]
        public dynamic Class { get; set; }

        [JsonProperty("booleanOperation")]
        public long BooleanOperation { get; set; }

        [JsonProperty("clippingMaskMode", NullValueHandling = NullValueHandling.Ignore)]
        public long? ClippingMaskMode { get; set; }

        [JsonProperty("do_objectID")]
        public string DoObjectId { get; set; }

        [JsonProperty("exportOptions")]
        public ExportOptions ExportOptions { get; set; }

        [JsonProperty("flow", NullValueHandling = NullValueHandling.Ignore)]
        public FlowConnection Flow { get; set; }

        [JsonProperty("frame")]
        public Rect Frame { get; set; }

        [JsonProperty("groupLayout", NullValueHandling = NullValueHandling.Ignore)]
        public GroupLayout GroupLayout { get; set; }

        [JsonProperty("hasClickThrough", NullValueHandling = NullValueHandling.Ignore)]
        public bool? HasClickThrough { get; set; }

        [JsonProperty("hasClippingMask", NullValueHandling = NullValueHandling.Ignore)]
        public bool? HasClippingMask { get; set; }

        [JsonProperty("isFixedToViewport")]
        public bool IsFixedToViewport { get; set; }

        [JsonProperty("isFlippedHorizontal")]
        public bool IsFlippedHorizontal { get; set; }

        [JsonProperty("isFlippedVertical")]
        public bool IsFlippedVertical { get; set; }

        [JsonProperty("isLocked")]
        public bool IsLocked { get; set; }

        [JsonProperty("isVisible")]
        public bool IsVisible { get; set; }

        [JsonProperty("layerListExpandedType")]
        public long LayerListExpandedType { get; set; }

        [JsonProperty("layers", NullValueHandling = NullValueHandling.Ignore)]
        public OriginalMasterLayer[] Layers { get; set; }

        [JsonProperty("maintainScrollPosition", NullValueHandling = NullValueHandling.Ignore)]
        public bool? MaintainScrollPosition { get; set; }

        [JsonProperty("name")]
        public string Name { get; set; }

        [JsonProperty("nameIsFixed")]
        public bool NameIsFixed { get; set; }

        /// <summary>
        /// Bitfield representing the resizing constraint
        /// </summary>
        [JsonProperty("resizingConstraint")]
        public long ResizingConstraint { get; set; }

        [JsonProperty("resizingType")]
        public long ResizingType { get; set; }

        [JsonProperty("rotation")]
        public double Rotation { get; set; }

        [JsonProperty("sharedStyleID", NullValueHandling = NullValueHandling.Ignore)]
        public string SharedStyleId { get; set; }

        [JsonProperty("shouldBreakMaskChain")]
        public bool ShouldBreakMaskChain { get; set; }

        [JsonProperty("style", NullValueHandling = NullValueHandling.Ignore)]
        public Style Style { get; set; }

        [JsonProperty("userInfo", NullValueHandling = NullValueHandling.Ignore)]
        public Dictionary<string, dynamic> UserInfo { get; set; }

        [JsonProperty("edited", NullValueHandling = NullValueHandling.Ignore)]
        public bool? Edited { get; set; }

        [JsonProperty("isClosed", NullValueHandling = NullValueHandling.Ignore)]
        public bool? IsClosed { get; set; }

        [JsonProperty("pointRadiusBehaviour", NullValueHandling = NullValueHandling.Ignore)]
        public long? PointRadiusBehaviour { get; set; }

        [JsonProperty("points", NullValueHandling = NullValueHandling.Ignore)]
        public CurvePoint[] Points { get; set; }

        [JsonProperty("numberOfPoints", NullValueHandling = NullValueHandling.Ignore)]
        public long? NumberOfPoints { get; set; }

        [JsonProperty("fixedRadius", NullValueHandling = NullValueHandling.Ignore)]
        public double? FixedRadius { get; set; }

        [JsonProperty("hasConvertedToNewRoundCorners", NullValueHandling = NullValueHandling.Ignore)]
        public bool? HasConvertedToNewRoundCorners { get; set; }

        [JsonProperty("needsConvertionToNewRoundCorners", NullValueHandling = NullValueHandling.Ignore)]
        public bool? NeedsConvertionToNewRoundCorners { get; set; }

        [JsonProperty("radius", NullValueHandling = NullValueHandling.Ignore)]
        public double? Radius { get; set; }

        [JsonProperty("isEquilateral", NullValueHandling = NullValueHandling.Ignore)]
        public bool? IsEquilateral { get; set; }

        [JsonProperty("windingRule", NullValueHandling = NullValueHandling.Ignore)]
        public long? WindingRule { get; set; }

        [JsonProperty("attributedString", NullValueHandling = NullValueHandling.Ignore)]
        public AttributedString AttributedString { get; set; }

        [JsonProperty("automaticallyDrawOnUnderlyingPath", NullValueHandling = NullValueHandling.Ignore)]
        public bool? AutomaticallyDrawOnUnderlyingPath { get; set; }

        [JsonProperty("dontSynchroniseWithSymbol", NullValueHandling = NullValueHandling.Ignore)]
        public bool? DontSynchroniseWithSymbol { get; set; }

        [JsonProperty("glyphBounds", NullValueHandling = NullValueHandling.Ignore)]
        public string GlyphBounds { get; set; }

        [JsonProperty("lineSpacingBehaviour", NullValueHandling = NullValueHandling.Ignore)]
        public long? LineSpacingBehaviour { get; set; }

        [JsonProperty("textBehaviour", NullValueHandling = NullValueHandling.Ignore)]
        public long? TextBehaviour { get; set; }

        [JsonProperty("horizontalSpacing", NullValueHandling = NullValueHandling.Ignore)]
        public double? HorizontalSpacing { get; set; }

        [JsonProperty("overrideValues", NullValueHandling = NullValueHandling.Ignore)]
        public OverrideValue[] OverrideValues { get; set; }

        [JsonProperty("scale", NullValueHandling = NullValueHandling.Ignore)]
        public double? Scale { get; set; }

        [JsonProperty("symbolID", NullValueHandling = NullValueHandling.Ignore)]
        public string SymbolId { get; set; }

        [JsonProperty("verticalSpacing", NullValueHandling = NullValueHandling.Ignore)]
        public double? VerticalSpacing { get; set; }

        [JsonProperty("backgroundColor", NullValueHandling = NullValueHandling.Ignore)]
        public Color BackgroundColor { get; set; }

        [JsonProperty("hasBackgroundColor", NullValueHandling = NullValueHandling.Ignore)]
        public bool? HasBackgroundColor { get; set; }

        [JsonProperty("clippingMask", NullValueHandling = NullValueHandling.Ignore)]
        public string ClippingMask { get; set; }

        [JsonProperty("fillReplacesImage", NullValueHandling = NullValueHandling.Ignore)]
        public bool? FillReplacesImage { get; set; }

        [JsonProperty("image", NullValueHandling = NullValueHandling.Ignore)]
        public ImageElement Image { get; set; }

        [JsonProperty("intendedDPI", NullValueHandling = NullValueHandling.Ignore)]
        public long? IntendedDpi { get; set; }
    }

    /// <summary>
    /// Defines character strings and associated styling applied to character ranges
    /// </summary>
    public partial class AttributedString
    {
        [JsonProperty("_class")]
        public dynamic Class { get; set; }

        [JsonProperty("attributes")]
        public StringAttribute[] Attributes { get; set; }

        [JsonProperty("string")]
        public string String { get; set; }
    }

    /// <summary>
    /// Defines an attribute assigned to a range of characters in an attributed string
    /// </summary>
    public partial class StringAttribute
    {
        [JsonProperty("_class")]
        public dynamic Class { get; set; }

        [JsonProperty("attributes")]
        public AttributeAttributes Attributes { get; set; }

        [JsonProperty("length")]
        public long Length { get; set; }

        [JsonProperty("location")]
        public long Location { get; set; }
    }

    public partial class AttributeAttributes
    {
        [JsonProperty("kerning", NullValueHandling = NullValueHandling.Ignore)]
        public double? Kerning { get; set; }

        [JsonProperty("MSAttributedStringColorAttribute", NullValueHandling = NullValueHandling.Ignore)]
        public Color MsAttributedStringColorAttribute { get; set; }

        [JsonProperty("MSAttributedStringFontAttribute")]
        public FontDescriptor MsAttributedStringFontAttribute { get; set; }

        [JsonProperty("paragraphStyle", NullValueHandling = NullValueHandling.Ignore)]
        public ParagraphStyle ParagraphStyle { get; set; }

        [JsonProperty("textStyleVerticalAlignmentKey", NullValueHandling = NullValueHandling.Ignore)]
        public long? TextStyleVerticalAlignmentKey { get; set; }
    }

    /// <summary>
    /// Defines an individual symbol override
    /// </summary>
    public partial class OverrideValue
    {
        [JsonProperty("_class")]
        public dynamic Class { get; set; }

        [JsonProperty("do_objectID", NullValueHandling = NullValueHandling.Ignore)]
        public string DoObjectId { get; set; }

        [JsonProperty("overrideName")]
        public string OverrideName { get; set; }

        [JsonProperty("value")]
        public Value Value { get; set; }
    }

    /// <summary>
    /// Defines a reference to a file within the document bundle
    ///
    /// Defines inline base64 data
    /// </summary>
    public partial class Reference
    {
        [JsonProperty("_class")]
        public dynamic Class { get; set; }

        [JsonProperty("_ref")]
        public string Ref { get; set; }

        [JsonProperty("_ref_class")]
        public ImageRefClass RefClass { get; set; }

        [JsonProperty("data", NullValueHandling = NullValueHandling.Ignore)]
        public Data Data { get; set; }

        [JsonProperty("sha1", NullValueHandling = NullValueHandling.Ignore)]
        public Sha1 Sha1 { get; set; }
    }

    /// <summary>
    /// Defines a shape layer curve point
    /// </summary>
    public partial class CurvePoint
    {
        [JsonProperty("_class")]
        public dynamic Class { get; set; }

        [JsonProperty("cornerRadius")]
        public double CornerRadius { get; set; }

        [JsonProperty("curveFrom")]
        public string CurveFrom { get; set; }

        [JsonProperty("curveMode")]
        public long CurveMode { get; set; }

        [JsonProperty("curveTo")]
        public string CurveTo { get; set; }

        [JsonProperty("hasCurveFrom")]
        public bool HasCurveFrom { get; set; }

        [JsonProperty("hasCurveTo")]
        public bool HasCurveTo { get; set; }

        [JsonProperty("point")]
        public string Point { get; set; }
    }

    /// <summary>
    /// Defines the layout settings for an artboard or page
    /// </summary>
    public partial class LayoutGrid
    {
        [JsonProperty("_class")]
        public dynamic Class { get; set; }

        [JsonProperty("columnWidth")]
        public long ColumnWidth { get; set; }

        [JsonProperty("drawHorizontal")]
        public bool DrawHorizontal { get; set; }

        [JsonProperty("drawHorizontalLines")]
        public bool DrawHorizontalLines { get; set; }

        [JsonProperty("drawVertical")]
        public bool DrawVertical { get; set; }

        [JsonProperty("gutterHeight")]
        public long GutterHeight { get; set; }

        [JsonProperty("guttersOutside")]
        public bool GuttersOutside { get; set; }

        [JsonProperty("gutterWidth")]
        public long GutterWidth { get; set; }

        [JsonProperty("horizontalOffset")]
        public long HorizontalOffset { get; set; }

        [JsonProperty("isEnabled")]
        public bool IsEnabled { get; set; }

        [JsonProperty("numberOfColumns")]
        public long NumberOfColumns { get; set; }

        [JsonProperty("rowHeightMultiplication")]
        public long RowHeightMultiplication { get; set; }

        [JsonProperty("totalWidth")]
        public long TotalWidth { get; set; }
    }

    /// <summary>
    /// Defines override properties on symbol sources
    /// </summary>
    public partial class OverrideProperty
    {
        [JsonProperty("_class")]
        public dynamic Class { get; set; }

        [JsonProperty("canOverride")]
        public bool CanOverride { get; set; }

        [JsonProperty("overrideName")]
        public string OverrideName { get; set; }
    }

    public partial class OriginalMasterPresetDictionary
    {
    }

    /// <summary>
    /// Defines a text style that has been imported from a library
    /// </summary>
    public partial class ForeignTextStyle
    {
        [JsonProperty("_class")]
        public dynamic Class { get; set; }

        [JsonProperty("libraryID")]
        public string LibraryId { get; set; }

        [JsonProperty("localSharedStyle")]
        public SharedStyle LocalSharedStyle { get; set; }

        [JsonProperty("missingLibraryFontAcknowledged", NullValueHandling = NullValueHandling.Ignore)]
        public bool? MissingLibraryFontAcknowledged { get; set; }

        [JsonProperty("remoteStyleID")]
        public string RemoteStyleId { get; set; }

        [JsonProperty("sourceLibraryName")]
        public string SourceLibraryName { get; set; }

        [JsonProperty("symbolPrivate")]
        public bool SymbolPrivate { get; set; }
    }

    /// <summary>
    /// Defines a document's list of reusable styles
    /// </summary>
    public partial class SharedStyleContainer
    {
        [JsonProperty("_class")]
        public dynamic Class { get; set; }

        [JsonProperty("do_objectID", NullValueHandling = NullValueHandling.Ignore)]
        public string DoObjectId { get; set; }

        [JsonProperty("objects")]
        public SharedStyle[] Objects { get; set; }
    }

    /// <summary>
    /// Legacy object only retained for migrating older documents.
    /// </summary>
    public partial class SymbolContainer
    {
        [JsonProperty("_class")]
        public dynamic Class { get; set; }

        [JsonProperty("do_objectID", NullValueHandling = NullValueHandling.Ignore)]
        public string DoObjectId { get; set; }

        [JsonProperty("objects")]
        public dynamic[] Objects { get; set; }
    }

    /// <summary>
    /// Defines a document's list of reusable text styles
    /// </summary>
    public partial class SharedTextStyleContainer
    {
        [JsonProperty("_class")]
        public dynamic Class { get; set; }

        [JsonProperty("do_objectID", NullValueHandling = NullValueHandling.Ignore)]
        public string DoObjectId { get; set; }

        [JsonProperty("objects")]
        public SharedStyle[] Objects { get; set; }
    }

    /// <summary>
    /// Defines a reference to a file within the document bundle
    /// </summary>
    public partial class FileReference
    {
        [JsonProperty("_class")]
        public dynamic Class { get; set; }

        [JsonProperty("_ref")]
        public string Ref { get; set; }

        [JsonProperty("_ref_class")]
        public PageRefClass RefClass { get; set; }
    }

    /// <summary>
    /// Defines a document's list of swatches
    /// </summary>
    public partial class SwatchContainer
    {
        [JsonProperty("_class")]
        public dynamic Class { get; set; }

        [JsonProperty("do_objectID", NullValueHandling = NullValueHandling.Ignore)]
        public string DoObjectId { get; set; }

        [JsonProperty("objects")]
        public Swatch[] Objects { get; set; }
    }

    /// <summary>
    /// Contains metadata about the Sketch file - information about pages and artboards appearing
    /// in the file, fonts used, the version of Sketch used to save the file etc.
    /// </summary>
    public partial class Meta
    {
        [JsonProperty("app")]
        public SketchBundleIdentifier App { get; set; }

        [JsonProperty("appVersion")]
        public string AppVersion { get; set; }

        [JsonProperty("autosaved")]
        public long Autosaved { get; set; }

        [JsonProperty("build")]
        public long Build { get; set; }

        [JsonProperty("coeditCompatibilityVersion", NullValueHandling = NullValueHandling.Ignore)]
        public double? CoeditCompatibilityVersion { get; set; }

        [JsonProperty("commit")]
        public string Commit { get; set; }

        [JsonProperty("compatibilityVersion")]
        public dynamic CompatibilityVersion { get; set; }

        [JsonProperty("created")]
        public Created Created { get; set; }

        [JsonProperty("fonts")]
        public string[] Fonts { get; set; }

        [JsonProperty("pagesAndArtboards")]
        public PagesAndArtboards PagesAndArtboards { get; set; }

        [JsonProperty("saveHistory")]
        public string[] SaveHistory { get; set; }

        [JsonProperty("variant")]
        public SketchVariant Variant { get; set; }

        [JsonProperty("version")]
        public long Version { get; set; }
    }

    public partial class Created
    {
        [JsonProperty("app")]
        public SketchBundleIdentifier App { get; set; }

        [JsonProperty("appVersion")]
        public string AppVersion { get; set; }

        [JsonProperty("build")]
        public long Build { get; set; }

        [JsonProperty("coeditCompatibilityVersion", NullValueHandling = NullValueHandling.Ignore)]
        public double? CoeditCompatibilityVersion { get; set; }

        [JsonProperty("commit")]
        public string Commit { get; set; }

        [JsonProperty("compatibilityVersion")]
        public double CompatibilityVersion { get; set; }

        [JsonProperty("variant")]
        public SketchVariant Variant { get; set; }

        [JsonProperty("version")]
        public double Version { get; set; }
    }

    public partial class PagesAndArtboards
    {
    }

    /// <summary>
    /// Page layers are the top level organisational abstraction within a document
    /// </summary>
    public partial class PageClass
    {
        [JsonProperty("_class")]
        public dynamic Class { get; set; }

        [JsonProperty("booleanOperation")]
        public long BooleanOperation { get; set; }

        [JsonProperty("clippingMaskMode", NullValueHandling = NullValueHandling.Ignore)]
        public long? ClippingMaskMode { get; set; }

        [JsonProperty("do_objectID")]
        public string DoObjectId { get; set; }

        [JsonProperty("exportOptions")]
        public ExportOptions ExportOptions { get; set; }

        [JsonProperty("flow", NullValueHandling = NullValueHandling.Ignore)]
        public FlowConnection Flow { get; set; }

        [JsonProperty("frame")]
        public Rect Frame { get; set; }

        [JsonProperty("grid", NullValueHandling = NullValueHandling.Ignore)]
        public SimpleGrid Grid { get; set; }

        [JsonProperty("groupLayout", NullValueHandling = NullValueHandling.Ignore)]
        public GroupLayout GroupLayout { get; set; }

        [JsonProperty("hasClickThrough")]
        public bool HasClickThrough { get; set; }

        [JsonProperty("hasClippingMask", NullValueHandling = NullValueHandling.Ignore)]
        public bool? HasClippingMask { get; set; }

        [JsonProperty("horizontalRulerData")]
        public RulerData HorizontalRulerData { get; set; }

        /// <summary>
        /// Deprecated, no longer used by Sketch Cloud
        /// </summary>
        [JsonProperty("includeInCloudUpload")]
        public bool IncludeInCloudUpload { get; set; }

        [JsonProperty("isFixedToViewport")]
        public bool IsFixedToViewport { get; set; }

        [JsonProperty("isFlippedHorizontal")]
        public bool IsFlippedHorizontal { get; set; }

        [JsonProperty("isFlippedVertical")]
        public bool IsFlippedVertical { get; set; }

        [JsonProperty("isLocked")]
        public bool IsLocked { get; set; }

        [JsonProperty("isVisible")]
        public bool IsVisible { get; set; }

        [JsonProperty("layerListExpandedType")]
        public long LayerListExpandedType { get; set; }

        /// <summary>
        /// Pages can contain any layer or layer group but no pages
        /// </summary>
        [JsonProperty("layers")]
        public PageLayer[] Layers { get; set; }

        [JsonProperty("layout", NullValueHandling = NullValueHandling.Ignore)]
        public LayoutGrid Layout { get; set; }

        [JsonProperty("maintainScrollPosition", NullValueHandling = NullValueHandling.Ignore)]
        public bool? MaintainScrollPosition { get; set; }

        [JsonProperty("name")]
        public string Name { get; set; }

        [JsonProperty("nameIsFixed")]
        public bool NameIsFixed { get; set; }

        /// <summary>
        /// Bitfield representing the resizing constraint
        /// </summary>
        [JsonProperty("resizingConstraint")]
        public long ResizingConstraint { get; set; }

        [JsonProperty("resizingType")]
        public long ResizingType { get; set; }

        [JsonProperty("rotation")]
        public double Rotation { get; set; }

        [JsonProperty("sharedStyleID", NullValueHandling = NullValueHandling.Ignore)]
        public string SharedStyleId { get; set; }

        [JsonProperty("shouldBreakMaskChain")]
        public bool ShouldBreakMaskChain { get; set; }

        [JsonProperty("style", NullValueHandling = NullValueHandling.Ignore)]
        public Style Style { get; set; }

        [JsonProperty("userInfo", NullValueHandling = NullValueHandling.Ignore)]
        public Dictionary<string, dynamic> UserInfo { get; set; }

        [JsonProperty("verticalRulerData")]
        public RulerData VerticalRulerData { get; set; }
    }

    /// <summary>
    /// Artboard layers are a document organisation aid. They have a fixed frame that usually map
    /// to variations of device dimensions or viewport sizes
    ///
    /// Group layers are a document organisation aid
    ///
    /// Oval layers are the result of adding an oval shape to the canvas
    ///
    /// Polygon layers are the result of adding a polygon shape to the canvas
    ///
    /// Rectangle layers are the result of adding a rectangle shape to the canvas
    ///
    /// Shape path layers are the result of adding a vector layer
    ///
    /// Star layers are the result of adding a star shape to the canvas
    ///
    /// Triangle layers are the result of adding a triangle shape to the canvas
    ///
    /// Shape groups layers group together multiple shape layers
    ///
    /// A text layer represents a discrete block or line of text
    ///
    /// A symbol source layer represents a reusable group of layers
    ///
    /// Symbol instance layers represent an instance of a symbol source
    ///
    /// Slice layers allow the content beneath their frame to be exported
    ///
    /// Hotspot layers define clickable hotspots for use with prototypes
    ///
    /// Bitmap layers house a single image
    /// </summary>
    public partial class PageLayer
    {
        [JsonProperty("_class")]
        public dynamic Class { get; set; }

        [JsonProperty("backgroundColor", NullValueHandling = NullValueHandling.Ignore)]
        public Color BackgroundColor { get; set; }

        [JsonProperty("booleanOperation")]
        public long BooleanOperation { get; set; }

        [JsonProperty("clippingMaskMode", NullValueHandling = NullValueHandling.Ignore)]
        public long? ClippingMaskMode { get; set; }

        [JsonProperty("do_objectID")]
        public string DoObjectId { get; set; }

        [JsonProperty("exportOptions")]
        public ExportOptions ExportOptions { get; set; }

        [JsonProperty("flow", NullValueHandling = NullValueHandling.Ignore)]
        public FlowConnection Flow { get; set; }

        [JsonProperty("frame")]
        public Rect Frame { get; set; }

        [JsonProperty("grid", NullValueHandling = NullValueHandling.Ignore)]
        public SimpleGrid Grid { get; set; }

        [JsonProperty("groupLayout", NullValueHandling = NullValueHandling.Ignore)]
        public GroupLayout GroupLayout { get; set; }

        [JsonProperty("hasBackgroundColor", NullValueHandling = NullValueHandling.Ignore)]
        public bool? HasBackgroundColor { get; set; }

        [JsonProperty("hasClickThrough", NullValueHandling = NullValueHandling.Ignore)]
        public bool? HasClickThrough { get; set; }

        [JsonProperty("hasClippingMask", NullValueHandling = NullValueHandling.Ignore)]
        public bool? HasClippingMask { get; set; }

        [JsonProperty("horizontalRulerData", NullValueHandling = NullValueHandling.Ignore)]
        public RulerData HorizontalRulerData { get; set; }

        [JsonProperty("includeBackgroundColorInExport", NullValueHandling = NullValueHandling.Ignore)]
        public bool? IncludeBackgroundColorInExport { get; set; }

        /// <summary>
        /// Deprecated, no longer used by Sketch Cloud
        /// </summary>
        [JsonProperty("includeInCloudUpload", NullValueHandling = NullValueHandling.Ignore)]
        public bool? IncludeInCloudUpload { get; set; }

        [JsonProperty("isFixedToViewport")]
        public bool IsFixedToViewport { get; set; }

        [JsonProperty("isFlippedHorizontal")]
        public bool IsFlippedHorizontal { get; set; }

        [JsonProperty("isFlippedVertical")]
        public bool IsFlippedVertical { get; set; }

        [JsonProperty("isFlowHome", NullValueHandling = NullValueHandling.Ignore)]
        public bool? IsFlowHome { get; set; }

        [JsonProperty("isLocked")]
        public bool IsLocked { get; set; }

        [JsonProperty("isVisible")]
        public bool IsVisible { get; set; }

        [JsonProperty("layerListExpandedType")]
        public long LayerListExpandedType { get; set; }

        /// <summary>
        /// Artboards can contain any layer or layer group except root layers such as other artboards
        /// and symbol sources
        ///
        /// Symbol sources can contain any layer or layer group except root layers such as artboards
        /// and other symbol sources
        /// </summary>
        [JsonProperty("layers", NullValueHandling = NullValueHandling.Ignore)]
        public OriginalMasterLayer[] Layers { get; set; }

        [JsonProperty("layout", NullValueHandling = NullValueHandling.Ignore)]
        public LayoutGrid Layout { get; set; }

        [JsonProperty("maintainScrollPosition", NullValueHandling = NullValueHandling.Ignore)]
        public bool? MaintainScrollPosition { get; set; }

        [JsonProperty("name")]
        public string Name { get; set; }

        [JsonProperty("nameIsFixed")]
        public bool NameIsFixed { get; set; }

        [JsonProperty("presetDictionary", NullValueHandling = NullValueHandling.Ignore)]
        public LayerPresetDictionary PresetDictionary { get; set; }

        [JsonProperty("resizesContent", NullValueHandling = NullValueHandling.Ignore)]
        public bool? ResizesContent { get; set; }

        /// <summary>
        /// Bitfield representing the resizing constraint
        /// </summary>
        [JsonProperty("resizingConstraint")]
        public long ResizingConstraint { get; set; }

        [JsonProperty("resizingType")]
        public long ResizingType { get; set; }

        [JsonProperty("rotation")]
        public double Rotation { get; set; }

        [JsonProperty("sharedStyleID", NullValueHandling = NullValueHandling.Ignore)]
        public string SharedStyleId { get; set; }

        [JsonProperty("shouldBreakMaskChain")]
        public bool ShouldBreakMaskChain { get; set; }

        [JsonProperty("style", NullValueHandling = NullValueHandling.Ignore)]
        public Style Style { get; set; }

        [JsonProperty("userInfo", NullValueHandling = NullValueHandling.Ignore)]
        public Dictionary<string, dynamic> UserInfo { get; set; }

        [JsonProperty("verticalRulerData", NullValueHandling = NullValueHandling.Ignore)]
        public RulerData VerticalRulerData { get; set; }

        [JsonProperty("edited", NullValueHandling = NullValueHandling.Ignore)]
        public bool? Edited { get; set; }

        [JsonProperty("isClosed", NullValueHandling = NullValueHandling.Ignore)]
        public bool? IsClosed { get; set; }

        [JsonProperty("pointRadiusBehaviour", NullValueHandling = NullValueHandling.Ignore)]
        public long? PointRadiusBehaviour { get; set; }

        [JsonProperty("points", NullValueHandling = NullValueHandling.Ignore)]
        public CurvePoint[] Points { get; set; }

        [JsonProperty("numberOfPoints", NullValueHandling = NullValueHandling.Ignore)]
        public long? NumberOfPoints { get; set; }

        [JsonProperty("fixedRadius", NullValueHandling = NullValueHandling.Ignore)]
        public double? FixedRadius { get; set; }

        [JsonProperty("hasConvertedToNewRoundCorners", NullValueHandling = NullValueHandling.Ignore)]
        public bool? HasConvertedToNewRoundCorners { get; set; }

        [JsonProperty("needsConvertionToNewRoundCorners", NullValueHandling = NullValueHandling.Ignore)]
        public bool? NeedsConvertionToNewRoundCorners { get; set; }

        [JsonProperty("radius", NullValueHandling = NullValueHandling.Ignore)]
        public double? Radius { get; set; }

        [JsonProperty("isEquilateral", NullValueHandling = NullValueHandling.Ignore)]
        public bool? IsEquilateral { get; set; }

        [JsonProperty("windingRule", NullValueHandling = NullValueHandling.Ignore)]
        public long? WindingRule { get; set; }

        [JsonProperty("attributedString", NullValueHandling = NullValueHandling.Ignore)]
        public AttributedString AttributedString { get; set; }

        [JsonProperty("automaticallyDrawOnUnderlyingPath", NullValueHandling = NullValueHandling.Ignore)]
        public bool? AutomaticallyDrawOnUnderlyingPath { get; set; }

        [JsonProperty("dontSynchroniseWithSymbol", NullValueHandling = NullValueHandling.Ignore)]
        public bool? DontSynchroniseWithSymbol { get; set; }

        [JsonProperty("glyphBounds", NullValueHandling = NullValueHandling.Ignore)]
        public string GlyphBounds { get; set; }

        [JsonProperty("lineSpacingBehaviour", NullValueHandling = NullValueHandling.Ignore)]
        public long? LineSpacingBehaviour { get; set; }

        [JsonProperty("textBehaviour", NullValueHandling = NullValueHandling.Ignore)]
        public long? TextBehaviour { get; set; }

        [JsonProperty("allowsOverrides", NullValueHandling = NullValueHandling.Ignore)]
        public bool? AllowsOverrides { get; set; }

        [JsonProperty("includeBackgroundColorInInstance", NullValueHandling = NullValueHandling.Ignore)]
        public bool? IncludeBackgroundColorInInstance { get; set; }

        [JsonProperty("overrideProperties", NullValueHandling = NullValueHandling.Ignore)]
        public OverrideProperty[] OverrideProperties { get; set; }

        [JsonProperty("symbolID", NullValueHandling = NullValueHandling.Ignore)]
        public string SymbolId { get; set; }

        [JsonProperty("horizontalSpacing", NullValueHandling = NullValueHandling.Ignore)]
        public double? HorizontalSpacing { get; set; }

        [JsonProperty("overrideValues", NullValueHandling = NullValueHandling.Ignore)]
        public OverrideValue[] OverrideValues { get; set; }

        [JsonProperty("scale", NullValueHandling = NullValueHandling.Ignore)]
        public double? Scale { get; set; }

        [JsonProperty("verticalSpacing", NullValueHandling = NullValueHandling.Ignore)]
        public double? VerticalSpacing { get; set; }

        [JsonProperty("clippingMask", NullValueHandling = NullValueHandling.Ignore)]
        public string ClippingMask { get; set; }

        [JsonProperty("fillReplacesImage", NullValueHandling = NullValueHandling.Ignore)]
        public bool? FillReplacesImage { get; set; }

        [JsonProperty("image", NullValueHandling = NullValueHandling.Ignore)]
        public ImageElement Image { get; set; }

        [JsonProperty("intendedDPI", NullValueHandling = NullValueHandling.Ignore)]
        public long? IntendedDpi { get; set; }
    }

    public partial class LayerPresetDictionary
    {
    }

    public partial class UserValue
    {
        [JsonProperty("expandedSymbolPathsInSidebar", NullValueHandling = NullValueHandling.Ignore)]
        public dynamic[] ExpandedSymbolPathsInSidebar { get; set; }

        [JsonProperty("expandedTextStylePathsInPopover", NullValueHandling = NullValueHandling.Ignore)]
        public dynamic[] ExpandedTextStylePathsInPopover { get; set; }

        [JsonProperty("libraryListCollapsed", NullValueHandling = NullValueHandling.Ignore)]
        public long? LibraryListCollapsed { get; set; }

        [JsonProperty("pageListCollapsed", NullValueHandling = NullValueHandling.Ignore)]
        public long? PageListCollapsed { get; set; }

        [JsonProperty("pageListHeight", NullValueHandling = NullValueHandling.Ignore)]
        public long? PageListHeight { get; set; }

        [JsonProperty("scrollOrigin", NullValueHandling = NullValueHandling.Ignore)]
        public string ScrollOrigin { get; set; }

        [JsonProperty("zoomValue", NullValueHandling = NullValueHandling.Ignore)]
        public double? ZoomValue { get; set; }
    }

    public partial class Workspace
    {
    }

    public enum ImageRefClass { MsFontData, MsImageData, MsImmutablePage };

    public enum FontDataRefClass { MsFontData, MsImageData };

    /// <summary>
    /// Enumeration of the file formats that can be selected in the layer export options
    /// </summary>
    public enum ExportFileFormat { Eps, Jpg, Pdf, Png, Svg, Tiff, Webp };

    public enum PageRefClass { MsImageData, MsImmutablePage };

    /// <summary>
    /// Enumeration of the Apple bundle ids for the various variants of Sketch
    /// </summary>
    public enum SketchBundleIdentifier { ComBohemiancodingSketch3, ComBohemiancodingSketch3Beta, ComBohemiancodingSketch3Experimental, ComBohemiancodingSketch3FeaturePreview, ComBohemiancodingSketch3Internal, ComBohemiancodingSketch3Private, ComBohemiancodingSketch3Testing };

    /// <summary>
    /// Enumeration of the Sketch variants
    /// </summary>
    public enum SketchVariant { Appstore, Beta, Experimental, FeaturePreview, Internal, Nonappstore, Private, Testing, Unittest };

    public partial struct Value
    {
        public Reference Reference;
        public string String;

        public static implicit operator Value(Reference Reference) => new Value { Reference = Reference };
        public static implicit operator Value(string String) => new Value { String = String };
    }

    public partial class SketchFileFormatDesigner
    {
        public static SketchFileFormatDesigner FromJson(string json) => JsonConvert.DeserializeObject<SketchFileFormatDesigner>(json, SketchConverter.FileFormat.Converter.Settings);
    }

    public static class Serialize
    {
        public static string ToJson(this SketchFileFormatDesigner self) => JsonConvert.SerializeObject(self, SketchConverter.FileFormat.Converter.Settings);
    }

    internal static class Converter
    {
        public static readonly JsonSerializerSettings Settings = new JsonSerializerSettings
        {
            MetadataPropertyHandling = MetadataPropertyHandling.Ignore,
            DateParseHandling = DateParseHandling.None,
            Converters =
            {
                ImageRefClassConverter.Singleton,
                FontDataRefClassConverter.Singleton,
                ExportFileFormatConverter.Singleton,
                ValueConverter.Singleton,
                PageRefClassConverter.Singleton,
                SketchBundleIdentifierConverter.Singleton,
                SketchVariantConverter.Singleton,
                new IsoDateTimeConverter { DateTimeStyles = DateTimeStyles.AssumeUniversal }
            },
        };
    }

    internal class PurpleMinMaxValueCheckConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(double) || t == typeof(double?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<double>(reader);
            if (value >= 0 && value <= 1)
            {
                return value;
            }
            throw new Exception("Cannot unmarshal type double");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (double)untypedValue;
            if (value >= 0 && value <= 1)
            {
                serializer.Serialize(writer, value);
                return;
            }
            throw new Exception("Cannot marshal type double");
        }

        public static readonly PurpleMinMaxValueCheckConverter Singleton = new PurpleMinMaxValueCheckConverter();
    }

    internal class ImageRefClassConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(ImageRefClass) || t == typeof(ImageRefClass?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "MSFontData":
                    return ImageRefClass.MsFontData;
                case "MSImageData":
                    return ImageRefClass.MsImageData;
                case "MSImmutablePage":
                    return ImageRefClass.MsImmutablePage;
            }
            throw new Exception("Cannot unmarshal type ImageRefClass");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (ImageRefClass)untypedValue;
            switch (value)
            {
                case ImageRefClass.MsFontData:
                    serializer.Serialize(writer, "MSFontData");
                    return;
                case ImageRefClass.MsImageData:
                    serializer.Serialize(writer, "MSImageData");
                    return;
                case ImageRefClass.MsImmutablePage:
                    serializer.Serialize(writer, "MSImmutablePage");
                    return;
            }
            throw new Exception("Cannot marshal type ImageRefClass");
        }

        public static readonly ImageRefClassConverter Singleton = new ImageRefClassConverter();
    }

    internal class FontDataRefClassConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(FontDataRefClass) || t == typeof(FontDataRefClass?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "MSFontData":
                    return FontDataRefClass.MsFontData;
                case "MSImageData":
                    return FontDataRefClass.MsImageData;
            }
            throw new Exception("Cannot unmarshal type FontDataRefClass");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (FontDataRefClass)untypedValue;
            switch (value)
            {
                case FontDataRefClass.MsFontData:
                    serializer.Serialize(writer, "MSFontData");
                    return;
                case FontDataRefClass.MsImageData:
                    serializer.Serialize(writer, "MSImageData");
                    return;
            }
            throw new Exception("Cannot marshal type FontDataRefClass");
        }

        public static readonly FontDataRefClassConverter Singleton = new FontDataRefClassConverter();
    }

    internal class FluffyMinMaxValueCheckConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(double) || t == typeof(double?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<double>(reader);
            if (value >= -100 && value <= 100)
            {
                return value;
            }
            throw new Exception("Cannot unmarshal type double");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (double)untypedValue;
            if (value >= -100 && value <= 100)
            {
                serializer.Serialize(writer, value);
                return;
            }
            throw new Exception("Cannot marshal type double");
        }

        public static readonly FluffyMinMaxValueCheckConverter Singleton = new FluffyMinMaxValueCheckConverter();
    }

    internal class ExportFileFormatConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(ExportFileFormat) || t == typeof(ExportFileFormat?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "eps":
                    return ExportFileFormat.Eps;
                case "jpg":
                    return ExportFileFormat.Jpg;
                case "pdf":
                    return ExportFileFormat.Pdf;
                case "png":
                    return ExportFileFormat.Png;
                case "svg":
                    return ExportFileFormat.Svg;
                case "tiff":
                    return ExportFileFormat.Tiff;
                case "webp":
                    return ExportFileFormat.Webp;
            }
            throw new Exception("Cannot unmarshal type ExportFileFormat");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (ExportFileFormat)untypedValue;
            switch (value)
            {
                case ExportFileFormat.Eps:
                    serializer.Serialize(writer, "eps");
                    return;
                case ExportFileFormat.Jpg:
                    serializer.Serialize(writer, "jpg");
                    return;
                case ExportFileFormat.Pdf:
                    serializer.Serialize(writer, "pdf");
                    return;
                case ExportFileFormat.Png:
                    serializer.Serialize(writer, "png");
                    return;
                case ExportFileFormat.Svg:
                    serializer.Serialize(writer, "svg");
                    return;
                case ExportFileFormat.Tiff:
                    serializer.Serialize(writer, "tiff");
                    return;
                case ExportFileFormat.Webp:
                    serializer.Serialize(writer, "webp");
                    return;
            }
            throw new Exception("Cannot marshal type ExportFileFormat");
        }

        public static readonly ExportFileFormatConverter Singleton = new ExportFileFormatConverter();
    }

    internal class ValueConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Value) || t == typeof(Value?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.String:
                case JsonToken.Date:
                    var stringValue = serializer.Deserialize<string>(reader);
                    return new Value { String = stringValue };
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<Reference>(reader);
                    return new Value { Reference = objectValue };
            }
            throw new Exception("Cannot unmarshal type Value");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (Value)untypedValue;
            if (value.String != null)
            {
                serializer.Serialize(writer, value.String);
                return;
            }
            if (value.Reference != null)
            {
                serializer.Serialize(writer, value.Reference);
                return;
            }
            throw new Exception("Cannot marshal type Value");
        }

        public static readonly ValueConverter Singleton = new ValueConverter();
    }

    internal class PageRefClassConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(PageRefClass) || t == typeof(PageRefClass?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "MSImageData":
                    return PageRefClass.MsImageData;
                case "MSImmutablePage":
                    return PageRefClass.MsImmutablePage;
            }
            throw new Exception("Cannot unmarshal type PageRefClass");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (PageRefClass)untypedValue;
            switch (value)
            {
                case PageRefClass.MsImageData:
                    serializer.Serialize(writer, "MSImageData");
                    return;
                case PageRefClass.MsImmutablePage:
                    serializer.Serialize(writer, "MSImmutablePage");
                    return;
            }
            throw new Exception("Cannot marshal type PageRefClass");
        }

        public static readonly PageRefClassConverter Singleton = new PageRefClassConverter();
    }

    internal class SketchBundleIdentifierConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(SketchBundleIdentifier) || t == typeof(SketchBundleIdentifier?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "com.bohemiancoding.sketch3":
                    return SketchBundleIdentifier.ComBohemiancodingSketch3;
                case "com.bohemiancoding.sketch3.beta":
                    return SketchBundleIdentifier.ComBohemiancodingSketch3Beta;
                case "com.bohemiancoding.sketch3.experimental":
                    return SketchBundleIdentifier.ComBohemiancodingSketch3Experimental;
                case "com.bohemiancoding.sketch3.feature-preview":
                    return SketchBundleIdentifier.ComBohemiancodingSketch3FeaturePreview;
                case "com.bohemiancoding.sketch3.internal":
                    return SketchBundleIdentifier.ComBohemiancodingSketch3Internal;
                case "com.bohemiancoding.sketch3.private":
                    return SketchBundleIdentifier.ComBohemiancodingSketch3Private;
                case "com.bohemiancoding.sketch3.testing":
                    return SketchBundleIdentifier.ComBohemiancodingSketch3Testing;
            }
            throw new Exception("Cannot unmarshal type SketchBundleIdentifier");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (SketchBundleIdentifier)untypedValue;
            switch (value)
            {
                case SketchBundleIdentifier.ComBohemiancodingSketch3:
                    serializer.Serialize(writer, "com.bohemiancoding.sketch3");
                    return;
                case SketchBundleIdentifier.ComBohemiancodingSketch3Beta:
                    serializer.Serialize(writer, "com.bohemiancoding.sketch3.beta");
                    return;
                case SketchBundleIdentifier.ComBohemiancodingSketch3Experimental:
                    serializer.Serialize(writer, "com.bohemiancoding.sketch3.experimental");
                    return;
                case SketchBundleIdentifier.ComBohemiancodingSketch3FeaturePreview:
                    serializer.Serialize(writer, "com.bohemiancoding.sketch3.feature-preview");
                    return;
                case SketchBundleIdentifier.ComBohemiancodingSketch3Internal:
                    serializer.Serialize(writer, "com.bohemiancoding.sketch3.internal");
                    return;
                case SketchBundleIdentifier.ComBohemiancodingSketch3Private:
                    serializer.Serialize(writer, "com.bohemiancoding.sketch3.private");
                    return;
                case SketchBundleIdentifier.ComBohemiancodingSketch3Testing:
                    serializer.Serialize(writer, "com.bohemiancoding.sketch3.testing");
                    return;
            }
            throw new Exception("Cannot marshal type SketchBundleIdentifier");
        }

        public static readonly SketchBundleIdentifierConverter Singleton = new SketchBundleIdentifierConverter();
    }

    internal class SketchVariantConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(SketchVariant) || t == typeof(SketchVariant?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "APPSTORE":
                    return SketchVariant.Appstore;
                case "BETA":
                    return SketchVariant.Beta;
                case "EXPERIMENTAL":
                    return SketchVariant.Experimental;
                case "FEATURE_PREVIEW":
                    return SketchVariant.FeaturePreview;
                case "INTERNAL":
                    return SketchVariant.Internal;
                case "NONAPPSTORE":
                    return SketchVariant.Nonappstore;
                case "PRIVATE":
                    return SketchVariant.Private;
                case "TESTING":
                    return SketchVariant.Testing;
                case "UNITTEST":
                    return SketchVariant.Unittest;
            }
            throw new Exception("Cannot unmarshal type SketchVariant");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (SketchVariant)untypedValue;
            switch (value)
            {
                case SketchVariant.Appstore:
                    serializer.Serialize(writer, "APPSTORE");
                    return;
                case SketchVariant.Beta:
                    serializer.Serialize(writer, "BETA");
                    return;
                case SketchVariant.Experimental:
                    serializer.Serialize(writer, "EXPERIMENTAL");
                    return;
                case SketchVariant.FeaturePreview:
                    serializer.Serialize(writer, "FEATURE_PREVIEW");
                    return;
                case SketchVariant.Internal:
                    serializer.Serialize(writer, "INTERNAL");
                    return;
                case SketchVariant.Nonappstore:
                    serializer.Serialize(writer, "NONAPPSTORE");
                    return;
                case SketchVariant.Private:
                    serializer.Serialize(writer, "PRIVATE");
                    return;
                case SketchVariant.Testing:
                    serializer.Serialize(writer, "TESTING");
                    return;
                case SketchVariant.Unittest:
                    serializer.Serialize(writer, "UNITTEST");
                    return;
            }
            throw new Exception("Cannot marshal type SketchVariant");
        }

        public static readonly SketchVariantConverter Singleton = new SketchVariantConverter();
    }
}
